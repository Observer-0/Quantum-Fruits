"""
TwoPhase Cosmological Model (TCP Model)
= Thermal Spacetime Feedback with Entropic Expansion-Deflation Cycles
Based on: Hubble Tension as ensemble average of pulsating universe

Author: Adrian Zander (Quantum Fruits)
Physics: Phase-transition cosmology inspired by der8auer's two-phase cooling
"""

import numpy as np
import matplotlib.pyplot as plt
from dataclasses import dataclass
from enum import Enum

# ============================================================================
# CONSTANTS & PARAMETERS
# ============================================================================

class Phase(Enum):
    """Universe phase state"""
    EXPANSION = 1      # Gas phase: High entropy → dV/dt > 0
    DEFLATION = -1     # Liquid phase: Cooling → dV/dt < 0

@dataclass
class CosmologicalConstants:
    """Model constants with SI-labelled reference scales"""
    l_P: float = 1.616e-35       # Planck length (m)
    sigma_P: float = 8.713e-79   # Planck spacetime cell ħG/c^4 (m·s)
    T_boiling: float = 61.0      # Boiling point of universe (K) - TUNABLE
    H_0_mean: float = 70.0       # Mean Hubble constant (km/s/Mpc)
    H_expansion: float = 73.0    # Expansion phase measurement
    H_deflation: float = 67.0    # Deflation phase measurement

# ============================================================================
# CORE UNIVERSE CLASS
# ============================================================================

class TwoPhaseUniverse:
    """
    Simulates universe evolution with thermal spacetime feedback.
    
    Phases:
    - EXPANSION: High entropy → accelerated expansion (dA/dt > 0)
    - DEFLATION: Entropy loss → contraction (dA/dt < 0)
    - Cycle repeats when rethermalization occurs
    """
    
    def __init__(self, constants: CosmologicalConstants = None):
        self.const = constants or CosmologicalConstants()
        
        # State variables
        self.time = 0.0
        self.scale_factor = 1.0              # a(t), universe size
        self.temperature = self.const.T_boiling * 0.8  # Start cool
        self.entropy = 400.0                 # bits (initial)
        self.hubble_parameter = 0.0          # H(t)
        self.phase = Phase.EXPANSION
        
        # History tracking
        self.history = {
            'time': [],
            'scale_factor': [],
            'temperature': [],
            'entropy': [],
            'hubble': [],
            'phase': []
        }
    
    def compute_hubble_parameter(self) -> float:
        """
        H(t) = d(ln a)/dt = (1/a) * da/dt
        
        Modulated by temperature relative to boiling point.
        At T=T_boil: expansion maximal
        At T→0: contraction kicks in
        """
        temp_ratio = self.temperature / self.const.T_boiling
        
        # Base oscillation with temperature coupling
        if self.phase == Phase.EXPANSION:
            H = self.const.H_expansion * temp_ratio
        else:  # DEFLATION
            H = -self.const.H_deflation * (1 - temp_ratio)
        
        return H
    
    def compute_entropy_rate(self) -> float:
        """
        dS/dt = entropy production/dissipation rate
        
        - Expansion phase: dS/dt > 0 (entropy grows)
        - Deflation phase: dS/dt < 0 (entropy decreases)
        - Hawking radiation provides continuous rethermalization
        """
        if self.phase == Phase.EXPANSION:
            # Entropy increases during expansion (2nd law)
            dS_dt = 0.5 * np.sin(self.time / 10.0) + 0.3
        else:
            # Entropy dissipates during deflation
            dS_dt = -0.2 * np.cos(self.time / 10.0)
        
        return dS_dt
    
    def phase_transition_check(self) -> None:
        """
        Determine if universe should switch phases.
        
        Criteria:
        - EXPANSION → DEFLATION: T drops below critical, entropy peaks
        - DEFLATION → EXPANSION: T regenerated by rethermalization
        """
        if self.phase == Phase.EXPANSION:
            # Switch to deflation if cooling sufficient
            if self.temperature < self.const.T_boiling * 0.3:
                self.phase = Phase.DEFLATION
                print(f"[t={self.time:.2f}] Phase transition: EXPANSION → DEFLATION")
        else:
            # Switch back to expansion if rethermalized
            if self.temperature > self.const.T_boiling * 0.7:
                self.phase = Phase.EXPANSION
                print(f"[t={self.time:.2f}] Phase transition: DEFLATION → EXPANSION")
    
    def step(self, dt: float = 0.01) -> None:
        """
        Integrate universe state by one timestep.
        """
        # 1. Compute current Hubble parameter
        self.hubble_parameter = self.compute_hubble_parameter()
        
        # 2. Update scale factor: da/dt = H * a
        da_dt = self.hubble_parameter * self.scale_factor
        self.scale_factor += da_dt * dt
        
        # 3. Temperature evolution: simplified cooling curve
        if self.phase == Phase.EXPANSION:
            # Active cooling (radiator in expansion phase)
            dT_dt = -0.5 * (self.temperature - 20.0)
        else:
            # Rethermalization from dark energy/Hawking radiation
            dT_dt = 0.3 * (self.const.T_boiling - self.temperature)
        
        self.temperature += dT_dt * dt
        self.temperature = np.clip(self.temperature, 10.0, self.const.T_boiling)
        
        # 4. Entropy evolution
        dS_dt = self.compute_entropy_rate()
        self.entropy += dS_dt * dt
        
        # 5. Check for phase transitions
        self.phase_transition_check()
        
        # 6. Update time and record history
        self.time += dt
        self._record_state()
    
    def _record_state(self) -> None:
        """Save current state to history for plotting"""
        self.history['time'].append(self.time)
        self.history['scale_factor'].append(self.scale_factor)
        self.history['temperature'].append(self.temperature)
        self.history['entropy'].append(self.entropy)
        self.history['hubble'].append(self.hubble_parameter)
        self.history['phase'].append(self.phase.value)
    
    def simulate(self, duration: float = 100.0, dt: float = 0.01) -> None:
        """Run full simulation for given duration"""
        steps = int(duration / dt)
        for _ in range(steps):
            self.step(dt)
    
    def compute_hubble_mean(self) -> float:
        """Compute ensemble-averaged Hubble constant (resolution to Hubble Tension)"""
        return np.mean(np.abs(self.history['hubble']))
    
    def plot_results(self) -> None:
        """Visualize simulation results"""
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        fig.suptitle('Two-Phase Universe Evolution (TCP Model)', fontsize=16, fontweight='bold')
        
        time = np.array(self.history['time'])
        
        # Plot 1: Scale factor (cosmic expansion)
        ax = axes[0, 0]
        ax.plot(time, self.history['scale_factor'], 'b-', linewidth=2)
        ax.set_ylabel('Scale Factor a(t)', fontsize=11)
        ax.set_title('Expansion-Deflation Cycles', fontweight='bold')
        ax.grid(True, alpha=0.3)
        
        # Plot 2: Temperature (cooling/rethermalization)
        ax = axes[0, 1]
        ax.plot(time, self.history['temperature'], 'r-', linewidth=2)
        ax.axhline(y=self.const.T_boiling, color='orange', linestyle='--', label='Boiling point (61K)')
        ax.set_ylabel('Temperature (K)', fontsize=11)
        ax.set_title('Thermal Evolution', fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Plot 3: Hubble parameter (expansion rate)
        ax = axes[1, 0]
        ax.plot(time, self.history['hubble'], 'g-', linewidth=2, label='H(t)')
        ax.axhline(y=self.const.H_0_mean, color='purple', linestyle='--', linewidth=2, label=f'⟨H⟩ = {self.const.H_0_mean} km/s/Mpc')
        ax.axhline(y=self.const.H_expansion, color='red', linestyle=':', alpha=0.7, label=f'Expansion: {self.const.H_expansion}')
        ax.axhline(y=-self.const.H_deflation, color='blue', linestyle=':', alpha=0.7, label=f'Deflation: {self.const.H_deflation}')
        ax.set_ylabel('H(t) [km/s/Mpc]', fontsize=11)
        ax.set_xlabel('Time (a.u.)', fontsize=11)
        ax.set_title('Hubble Parameter Oscillation\n(Tension = phase difference)', fontweight='bold')
        ax.legend(fontsize=9)
        ax.grid(True, alpha=0.3)
        
        # Plot 4: Entropy (information content)
        ax = axes[1, 1]
        ax.plot(time, self.history['entropy'], 'm-', linewidth=2)
        ax.set_ylabel('Entropy S (bits)', fontsize=11)
        ax.set_xlabel('Time (a.u.)', fontsize=11)
        ax.set_title('Information Content Evolution', fontweight='bold')
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("TWO-PHASE COSMOLOGICAL MODEL (TCP)")
    print("Inspired by: Two-phase PC cooling (der8auer Aqua Exhalare)")
    print("=" * 70)
    print()
    
    # Initialize universe
    const = CosmologicalConstants()
    universe = TwoPhaseUniverse(const)
    
    # Run simulation
    print("[*] Running 100 cosmic cycles...")
    universe.simulate(duration=100.0, dt=0.05)
    
    # Results
    print()
    print("[✓] Simulation complete!")
    print(f"    Final scale factor: a(t) = {universe.scale_factor:.4f}")
    print(f"    Final temperature: T = {universe.temperature:.2f} K")
    print(f"    Final entropy: S = {universe.entropy:.1f} bits")
    print()
    print(f"[*] Hubble Tension Resolution:")
    print(f"    Mean ⟨H⟩ = {universe.compute_hubble_mean():.2f} km/s/Mpc")
    print(f"    Expansion phase: H+ = {const.H_expansion} km/s/Mpc")
    print(f"    Deflation phase: H- = {const.H_deflation} km/s/Mpc")
    print(f"    Difference (tension): ΔH = {const.H_expansion - const.H_deflation} km/s/Mpc")
    print()
    
    # Visualize
    print("[*] Generating plots...")
    universe.plot_results()
