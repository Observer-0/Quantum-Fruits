import sympy as sp

# Symbole und Konstanten
hbar, c, sigma_P = sp.symbols('hbar c sigma_P', positive=True)
G = sp.symbols('G', positive=True)
t, r, theta, phi = sp.symbols('t r theta phi')
M = sp.symbols('M', positive=True)
hbar, G, c, M = sp.symbols('hbar G c M', positive=True)
v2 = hbar * c**3 / (G * M**2)
X = hbar * G / v2
X2 = G**2 * M**2 / c**3

print("v^2 =", v2)
print("X =", X)
print("X2 =", X2)
print("Sind X und X2 gleich?", sp.simplify(X - X2) == 0)

# Metrik-Komponenten (Schwarzschild-Ansatz)
f = 1 - 2*G*M/(c**2*r)
g_tt = -f
g_rr = 1/f
g_thth = r**2
g_phph = r**2 * sp.sin(theta)**2

# Metrik-Tensor
g = sp.Matrix([
    [g_tt, 0, 0, 0],
    [0, g_rr, 0, 0],
    [0, 0, g_thth, 0],
    [0, 0, 0, g_phph]
])

# Symbolische Krümmung (Platzhalter)
R = sp.symbols('R')  # Ricci-Skalar
G_mn = sp.symbols('G_mn')  # Einstein-Tensor

# Modifizierte Feldgleichung
lhs = (hbar/(sigma_P*c**2))*G_mn + (1/(4*c))*g
rhs = (sigma_P*c**2/hbar)*sp.symbols('T_mn')

# Ausgabe
print("Modifizierte Feldgleichung:")
sp.pprint(lhs, use_unicode=True)
print("= ")
sp.pprint(rhs, use_unicode=True)

# Platz für eigene Schwarzloch-Lösung:
# z.B. Einsetzen von g, Berechnung von G_mn, T_mn, etc.

# Spin-2-Operator (symbolisch)
# z.B. Linearisiertes Feld: h_{mu nu}, D'Alembert-Operator, etc.
h_mn = sp.symbols('h_mn')
dalembert = sp.symbols('Box')
spin2_eq = dalembert*h_mn - (1/(4*c))*h_mn

print("\nSpin-2-Feldgleichung (symbolisch):")
sp.pprint(spin2_eq, use_unicode=True)